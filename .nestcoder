# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/dejavideo/src/views/style.ejs">

<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f0f0f0;
  }
  h1 {
    margin: 0;
    color: #333;
    text-align: center;
  }
  h2 {
    margin: 0 0 0.5em;
  }
  #channel-list,
  #video-queue {
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  .video-item {
    border-bottom: 1px solid #eee;
    padding: 15px 0;
  }
  .video-item:last-child {
    border-bottom: none;
  }
  .video-title {
    font-weight: bold;
    margin-bottom: 5px;
  }
  .video-description {
    color: #666;
    font-size: 0.9em;
  }
  #add-channel-form,
  #add-video-form {
    margin-top: 20px;
    background-color: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  select, input, textarea {
    width: 100%;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
  }
  button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background-color: #45a049;
  }
</style>
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/views/partials/channel-options.ejs">
<option value="">Select a Channel</option>
<% channels.forEach(function(channel) { %>
  <option value="<%= channel.channelId %>"><%= channel.title %></option>
<% }); %>
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/views/partials/channel-list.ejs">
<h2>Added Channels</h2>
<ul>
  <% channels.forEach(function(channel) { %>
    <li><%= channel.title %> (ID: <%= channel.channelId %>)</li>
  <% }); %>
</ul>
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-channels/youtube-channels.controller.ts">
import { Controller, Post, Body, Get, Param, Render } from '@nestjs/common';
import { YoutubeChannelsService } from './youtube-channels.service';
import { YoutubeChannel } from './youtube-channel.entity';

@Controller('youtube-channels')
export class YoutubeChannelsController {
  constructor(private readonly youtubeChannelsService: YoutubeChannelsService) {}

  @Post()
  async createChannel(@Body() channelData: Partial<YoutubeChannel>): Promise<YoutubeChannel> {
    return this.youtubeChannelsService.saveChannel(channelData);
  }

  @Get('options/:userId')
  @Render('partials/channel-options')
  async getChannelOptions(@Param('userId') userId: string): Promise<{ channels: YoutubeChannel[] }> {
    const channels = await this.youtubeChannelsService.getChannelsByUserId(userId);
    return { channels };
  }

  @Get('list/:userId')
  @Render('partials/channel-list')
  async getChannelList(@Param('userId') userId: string): Promise<{ channels: YoutubeChannel[] }> {
    const channels = await this.youtubeChannelsService.getChannelsByUserId(userId);
    return { channels };
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-channels/youtube-channels.service.ts">
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { YoutubeChannel } from './youtube-channel.entity';
import { google, youtube_v3 } from 'googleapis';

@Injectable()
export class YoutubeChannelsService {
  private youtube: youtube_v3.Youtube;

  constructor(
    @InjectRepository(YoutubeChannel)
    private youtubeChannelRepository: Repository<YoutubeChannel>,
  ) {
    const auth = new google.auth.GoogleAuth({
      keyFile: process.env.GOOGLE_APPLICATION_CREDENTIALS,
      scopes: ['https://www.googleapis.com/auth/youtube.readonly'],
    });

    this.youtube = google.youtube({ version: 'v3', auth });
  }

  async saveChannel(channelData: Partial<YoutubeChannel>): Promise<YoutubeChannel> {
    if (!channelData.title) {
      if (channelData.channelId) {
        try {
          const fetchedData = await this.fetchYoutubeChannelData(channelData.channelId);
          channelData.title = fetchedData.title;
        } catch (error) {
          if (error instanceof NotFoundException) {
            throw new BadRequestException('Channel not found');
          }
          throw error;
        }
      } else {
        throw new BadRequestException('Channel title or channelId is required');
      }
    }

    if (!channelData.title) {
      throw new BadRequestException('Failed to fetch channel title');
    }

    const channel = this.youtubeChannelRepository.create(channelData);
    return await this.youtubeChannelRepository.save(channel);
  }

  async getChannelsByUserId(userId: string): Promise<YoutubeChannel[]> {
    return await this.youtubeChannelRepository.find({ where: { userId } });
  }

  async fetchYoutubeChannelData(channelId: string): Promise<Partial<YoutubeChannel>> {
    try {
      const response = await this.youtube.channels.list({
        part: ['snippet'],
        id: [channelId],
      });

      if (response.data.items && response.data.items.length > 0) {
        const channel = response.data.items[0];
        return {
          channelId: channel.id,
          title: channel.snippet.title,
          description: channel.snippet.description,
        };
      } else {
        throw new NotFoundException('Channel not found');
      }
    } catch (error) {
      console.error('Error fetching YouTube channel data:', error);
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new Error('Failed to fetch YouTube channel data');
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-playlist/youtube-playlist.controller.ts">
import { Controller, Post, Body, Get, Param } from '@nestjs/common';
import { YoutubePlaylistService } from './youtube-playlist.service';
import { YoutubePlaylist } from './youtube-playlist.entity';

@Controller('youtube-playlists')
export class YoutubePlaylistController {
  constructor(private readonly youtubePlaylistService: YoutubePlaylistService) {}

  @Post()
  async createPlaylist(@Body() playlistData: Partial<YoutubePlaylist>): Promise<YoutubePlaylist> {
    return this.youtubePlaylistService.savePlaylist(playlistData);
  }

  @Get(':userId')
  async getPlaylistsByUserId(@Param('userId') userId: string): Promise<YoutubePlaylist[]> {
    return this.youtubePlaylistService.getPlaylistsByUserId(userId);
  }

  @Get('options/:channelId')
  async getPlaylistOptions(@Param('channelId') channelId: string): Promise<YoutubePlaylist[]> {
    return this.youtubePlaylistService.getPlaylistsByChannelId(channelId);
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-playlist/youtube-playlist.service.ts">
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { YoutubePlaylist } from './youtube-playlist.entity';
import { google, youtube_v3 } from 'googleapis';

@Injectable()
export class YoutubePlaylistService {
  private youtube: youtube_v3.Youtube;

  constructor(
    @InjectRepository(YoutubePlaylist)
    private youtubePlaylistRepository: Repository<YoutubePlaylist>,
  ) {
    const auth = new google.auth.GoogleAuth({
      keyFile: process.env.GOOGLE_APPLICATION_CREDENTIALS,
      scopes: ['https://www.googleapis.com/auth/youtube.readonly'],
    });

    this.youtube = google.youtube({ version: 'v3', auth });
  }

  async savePlaylist(playlistData: Partial<YoutubePlaylist>): Promise<YoutubePlaylist> {
    const playlist = this.youtubePlaylistRepository.create(playlistData);
    return await this.youtubePlaylistRepository.save(playlist);
  }

  async getPlaylistsByUserId(userId: string): Promise<YoutubePlaylist[]> {
    return await this.youtubePlaylistRepository.find({ where: { userId } });
  }

  async getPlaylistsByChannelId(channelId: string): Promise<YoutubePlaylist[]> {
    try {
      const response = await this.youtube.playlists.list({
        part: ['snippet'],
        channelId: channelId,
        maxResults: 50,
      });

      if (response.data.items && response.data.items.length > 0) {
        const playlists: YoutubePlaylist[] = [];
        response.data.items.map(async playlist => 
          playlists.push(await this.savePlaylist({
            playlistId: playlist.id,
            title: playlist.snippet.title,
            description: playlist.snippet.description,
            userId: '', // You might want to set this based on your application logic
          }))
        );
        return playlists;
      } else {
        return [];
      }
    } catch (error) {
      console.error('Error fetching YouTube playlists:', error);
      throw new Error('Failed to fetch YouTube playlists');
    }
  }

  async fetchYoutubePlaylistData(playlistId: string): Promise<Partial<YoutubePlaylist>> {
    try {
      const response = await this.youtube.playlists.list({
        part: ['snippet'],
        id: [playlistId],
      });

      if (response.data.items && response.data.items.length > 0) {
        const playlist = response.data.items[0];
        return {
          playlistId: playlist.id,
          title: playlist.snippet.title,
          description: playlist.snippet.description,
        };
      } else {
        throw new Error('Playlist not found');
      }
    } catch (error) {
      console.error('Error fetching YouTube playlist data:', error);
      throw new Error('Failed to fetch YouTube playlist data');
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-videos/youtube-videos.controller.ts">
import { Controller, Post, Body, Get, Param } from '@nestjs/common';
import { YoutubeVideosService } from './youtube-videos.service';
import { YoutubeVideo } from './youtube-video.entity';

@Controller('youtube-videos')
export class YoutubeVideosController {
  constructor(private readonly youtubeVideosService: YoutubeVideosService) {}

  @Post()
  async createVideo(@Body() videoData: Partial<YoutubeVideo>): Promise<YoutubeVideo> {
    return this.youtubeVideosService.saveVideo(videoData);
  }

  @Get(':userId')
  async getVideosByUserId(@Param('userId') userId: string): Promise<YoutubeVideo[]> {
    return this.youtubeVideosService.getVideosByUserId(userId);
  }

  @Get('options/:playlistId')
  async getVideoOptions(@Param('playlistId') playlistId: string): Promise<YoutubeVideo[]> {
    return this.youtubeVideosService.getVideosByPlaylistId(playlistId);
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/youtube-videos/youtube-videos.service.ts">
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { YoutubeVideo } from './youtube-video.entity';
import { google, youtube_v3 } from 'googleapis';

@Injectable()
export class YoutubeVideosService {
  private youtube: youtube_v3.Youtube;

  constructor(
    @InjectRepository(YoutubeVideo)
    private youtubeVideoRepository: Repository<YoutubeVideo>,
  ) {
    const auth = new google.auth.GoogleAuth({
      keyFile: process.env.GOOGLE_APPLICATION_CREDENTIALS,
      scopes: ['https://www.googleapis.com/auth/youtube.readonly'],
    });

    this.youtube = google.youtube({ version: 'v3', auth });
  }

  async saveVideo(videoData: Partial<YoutubeVideo>): Promise<YoutubeVideo> {
    const video = this.youtubeVideoRepository.create(videoData);
    return await this.youtubeVideoRepository.save(video);
  }

  async getVideosByUserId(userId: string): Promise<YoutubeVideo[]> {
    return await this.youtubeVideoRepository.find({ where: { userId } });
  }

  async getVideoById(videoId: string): Promise<YoutubeVideo> {
    return await this.youtubeVideoRepository.findOne({ where: { videoId } });
  }

  async getVideosByPlaylistId(playlistId: string): Promise<YoutubeVideo[]> {
    try {
      const response = await this.youtube.playlistItems.list({
        part: ['snippet'],
        playlistId: playlistId,
        maxResults: 50,
      });

      if (response.data.items && response.data.items.length > 0) {
        let videos: YoutubeVideo[] = [];
        response.data.items.map(async item => (
          videos.push(await this.saveVideo({
            videoId: item.snippet.resourceId.videoId,
            title: item.snippet.title,
            description: item.snippet.description,
            userId: '', // You might want to set this based on your application logic
            channelId: item.snippet.channelId,
            playlistId: playlistId,
          }))
        ));
      } else {
        return [];
      }
    } catch (error) {
      console.error('Error fetching YouTube playlist videos:', error);
      throw new Error('Failed to fetch YouTube playlist videos');
    }
  }

  async fetchYoutubeVideoData(videoId: string): Promise<Partial<YoutubeVideo>> {
    try {
      const response = await this.youtube.videos.list({
        part: ['snippet'],
        id: [videoId],
      });

      if (response.data.items && response.data.items.length > 0) {
        const video = response.data.items[0];
        return {
          videoId: video.id,
          title: video.snippet.title,
          description: video.snippet.description,
          channelId: video.snippet.channelId,
        };
      } else {
        throw new Error('Video not found');
      }
    } catch (error) {
      console.error('Error fetching YouTube video data:', error);
      throw new Error('Failed to fetch YouTube video data');
    }
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/video-timeline/video-timeline.controller.ts">
import { Controller, Post, Get, Body, Param } from '@nestjs/common';
import { VideoTimelineService } from './video-timeline.service';
import { VideoTimelineEntry } from './video-timeline-entry.entity';

@Controller('video-timeline')
export class VideoTimelineController {
  constructor(private videoTimelineService: VideoTimelineService) {}

  @Post()
  async addVideoToTimeline(
    @Body() body: { videoId: string; userId: string; publishDateTime: string },
  ): Promise<VideoTimelineEntry> {
    const { videoId, userId, publishDateTime } = body;
    return await this.videoTimelineService.addVideoToTimeline(
      videoId,
      userId,
      new Date(publishDateTime),
    );
  }

  @Get(':userId')
  async getTimelineForUser(@Param('userId') userId: string): Promise<VideoTimelineEntry[]> {
    return await this.videoTimelineService.getTimelineForUser(userId);
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/video-timeline/video-timeline.service.ts">
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { VideoTimelineEntry } from './video-timeline-entry.entity';
import { YoutubeVideosService } from '../youtube-videos/youtube-videos.service';

@Injectable()
export class VideoTimelineService {
  constructor(
    @InjectRepository(VideoTimelineEntry)
    private videoTimelineRepository: Repository<VideoTimelineEntry>,
    private youtubeVideosService: YoutubeVideosService,
  ) {}

  async addVideoToTimeline(videoId: string, userId: string, publishDateTime: Date): Promise<VideoTimelineEntry> {
    const video = await this.youtubeVideosService.getVideoById(videoId);
    if (!video) {
      throw new Error('Video not found');
    }

    const timelineEntry = this.videoTimelineRepository.create({
      video,
      userId,
      publishDateTime,
    });

    return await this.videoTimelineRepository.save(timelineEntry);
  }

  async getTimelineForUser(userId: string): Promise<VideoTimelineEntry[]> {
    return await this.videoTimelineRepository.find({
      where: { userId },
      relations: ['video'],
      order: { publishDateTime: 'ASC' },
    });
  }
}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/app.module.ts">
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { YoutubePlaylistModule } from './youtube-playlist/youtube-playlist.module';
import { YoutubeChannelsModule } from './youtube-channels/youtube-channels.module';
import { YoutubeVideosModule } from './youtube-videos/youtube-videos.module';
import { VideoTimelineModule } from './video-timeline/video-timeline.module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'sqlite',
      database: 'data/dejavideo.sqlite',
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      synchronize: true,
    }),
    YoutubePlaylistModule,
    YoutubeChannelsModule,
    YoutubeVideosModule,
    VideoTimelineModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
</FILE>
<FILE path="/home/travis/Projects/dejavideo/src/main.ts">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import * as cookieParser from 'cookie-parser';
import { CustomLogger } from './logger/custom-logger';
import { resolve } from 'path';
import * as dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

async function bootstrap(logger: CustomLogger) {
  const app = await NestFactory.create<NestExpressApplication>(AppModule, { logger });

  app.useStaticAssets(resolve('./src/public'));
  app.setBaseViewsDir(resolve('./src/views'));
  app.setViewEngine('ejs');

  app.use(cookieParser());

  // so browsers can use api
  app.enableCors({
    origin: '*',
  });
  
  await app.listen(3000);
}

const logger = new CustomLogger('Bootstrap');

bootstrap(logger);
</FILE>
<FILE path="src/views/index.ejs" TARGET>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DJ Video Queue</title>
  <script src="https://unpkg.com/htmx.org@1.9.2"></script>
  <%- include('style'); %> 
</head>
<body>
  <h1>DeJa Video</h1>

  <div id="add-video-form">
    <h2>Queue Video Event</h2>
    <form hx-post="/video-timeline" hx-target="#video-queue" hx-swap="afterbegin">
      <select name="channelId" hx-get="/youtube-channels/options/dj123" hx-target="this" hx-trigger="load" hx-swap="innerHTML">
        <%- include('partials/channel-options', { channels: [] }); %>
      </select>
      
      <select id="playlist-select" name="playlistId" hx-get="/youtube-playlists/options/${channelId}" hx-target="this" hx-trigger="load, channelId changed" hx-swap="innerHTML">
        <option value="">Select a Playlist</option>
      </select>
      
      <select id="video-select" name="videoId" hx-get="/youtube-videos/options/${playlistId}" hx-target="this" hx-trigger="load, playlistId changed" hx-swap="innerHTML">
        <option value="">Select a Video</option>
      </select>
      
      <label for="publishDateTime">Publish Date and Time:</label>
      <input type="datetime-local" id="publishDateTime" name="publishDateTime" required>
      
      <input type="hidden" name="userId" value="dj123">
      <button type="submit">Queue Video</button>
    </form>
  </div>
  <br />
  <div id="video-queue">
    <!-- This section will be populated with video items -->
  </div>

  <div id="add-channel-form">
    <h2>Add YouTube Channel</h2>
    <form hx-post="/youtube-channels" hx-target="#channel-list" hx-swap="beforeend">
      <input type="text" name="channelId" placeholder="YouTube Channel ID" required>
      <input type="hidden" name="userId" value="dj123">
      <button type="submit">Add Channel</button>
    </form>
  </div>
  <br />
  <div id="channel-list">
    <%- include('partials/channel-list', { channels: [] }); %>
  </div>

  <script>
    // Load initial video queue
    htmx.ajax('GET', '/video-timeline/dj123', {target: '#video-queue', swap: 'innerHTML'});
    
    // Load initial channel list
    htmx.ajax('GET', '/youtube-channels/options/dj123', {target: 'select[name="channelId"]', swap: 'innerHTML'});

    // Load initial added channels
    htmx.ajax('GET', '/youtube-channels/list/dj123', {target: '#channel-list', swap: 'innerHTML'});
  </script>
</body>
</html>
</FILE>
<REQUEST>
select playlist and select video should use hx-get programmatically instead of through attribute tags
</REQUEST>